The Fibonacci series is a sequence of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. 
The sequence begins 0, 1, 1, 2, 3, 5, 8, 13, 21, and continues infinitely, with each new number being the sum of the two before it.  
(0+1=1) (1+1=2) (1+2=3) (2+3=5)

The nth term of the Fibonacci Sequence is represented as Fn. It is given by the following recursive formula,
Fn = Fn-1 + Fn-2
where,
n > 1
The first term is 0,... i.e., F0 = 0
The second term is 1Sequence, i.e., F1 = 1

Recursive Approach
def recursive_fib(n):
    if n <= 1:
        return n
    else:
        return recursive_fib(n-1) + recursive_fib(n-2)

Time Complexity: O(2ⁿ) and Space Complexity: O(n)

Iterative Approach
def iterative_fib(n):
    if n <= 1:
        return n
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b

Time Complexity: O(n) and Space Complexity: O(1)

-> Memoization (Top-Down DP)
def fib_memo(n, memo={}):
    if n <= 1:
        return n
    if n in memo:
        return memo[n]

    memo[n] = fib_memo(n - 1, memo) + fib_memo(n - 2, memo)
    return memo[n]

Time Complexity: O(n) and Space Complexity: O(n)

-> Tabulation (Bottom-Up DP)
def fib_tab(n):
    if n <= 1:
        return n
    dp = [0] * (n + 1)
    dp[1] = 1

    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]

    return dp[n]
Time Complexity: O(n) and Space Complexity: O(n)

Matrix Representation: There's a special matrix (transformation matrix) that represents how Fibonacci numbers work.
It looks like this: [[1,1],[1,0]]
[[f(n+1),f(n)],[f(n),f(n-1)]]

def multiply(A, B):
    return [
        [A[0][0]*B[0][0] + A[0][1]*B[1][0],
         A[0][0]*B[0][1] + A[0][1]*B[1][1]],

        [A[1][0]*B[0][0] + A[1][1]*B[1][0],
         A[1][0]*B[0][1] + A[1][1]*B[1][1]]
    ]

def matrix_power(M, n):
    result = [[1, 0], [0, 1]]  # Identity matrix (2×2)

    while n > 0:
        if n % 2 == 1:
            result = multiply(result, M)
        M = multiply(M, M)
        n //= 2
    return result

def fib_matrix(n):
    if n <= 1:
        return n
    M = [[1, 1], [1, 0]]
    powered = matrix_power(M, n - 1)
    return powered[0][0]  # F(n)

Time Complexity: O(logn) and Space Complexity: O(1)

Fast Doubling Formula — O(log n)
Using these identities
F(2k)=F(k)⋅[2F(k+1)−F(k)]
F(2k+1)=F(k+1)^2+F(k)^2

def fib_fast_doubling(n):
    if n == 0:
        return (0, 1)   # returns (F(n), F(n+1))

    # Divide the problem
    a, b = fib_fast_doubling(n // 2)  # a = F(k), b = F(k+1)

    c = a * (2*b - a)           # F(2k)
    d = a*a + b*b               # F(2k + 1)

    if n % 2 == 0:
        return (c, d)
    else:
        return (d, c + d)

def fibonacci(n):
    return fib_fast_doubling(n)[0]

Time Complexity: O(logn) and Space Complexity: O(logn)

Addition Rule: The (m + n)-th Fibonacci Number can be directly obtained using F(m + n) = F(m) x F(n + 1) + F(m - 1) x F(n). 
This formula can be directly derived from the matrix representation.