Problem Statement - Given an integer array and an integer K, find the number of continuous subarrays whose sum equals K.
Arr = [1, 2, 3, -2, 2, 1, 3]
K = 4
Output 3

Explanation
The subarrays whose sum is 4 are:
[1, 2, 3, -2]
[3, -2, 2, 1]
[1, 3]
Hence, total valid subarrays = 3

Key Insight (Prefix Sum Invariant) - Let: prefixSum[j] = a[0] + a[1] + ... + a[j]
For a subarray (i+1 ... j) to have sum = K: prefixSum[j] - prefixSum[i] = K
                                          â‡’ prefixSum[i] = prefixSum[j] - K

So at every index, we only need to know:
How many times (currentPrefixSum - K) has appeared before.

Algorithm
1 Initialize a HashMap to store prefix sum frequencies.
2 Set map.put(0, 1) to handle subarrays starting at index 0.
3 Traverse the array while maintaining a running sum.
4 If (runningSum - K) exists in map, add its frequency to the count.
5 Update the map with current runningSum.

Time & Space Complexity 
| Type  | Complexity |
| ----- | ---------- |
| Time  | O(n)       |
| Space | O(n)       |

Java Implementation
import java.util.HashMap;

public class SubarraySumEqualsK {
    public static int countSubarrays(int[] arr, int k) {
        HashMap<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);

        int sum = 0;
        int count = 0;

        for (int num : arr) {
            sum += num;

            if (map.containsKey(sum - k)) {
                count += map.get(sum - k);
            }

            map.put(sum, map.getOrDefault(sum, 0) + 1);
        }
        return count;
    }

    public static void main(String[] args) {
        int[] arr = {1, 2, 3, -2, 2, 1, 3};
        int k = 4;
        System.out.println(countSubarrays(arr, k));
    }
}
